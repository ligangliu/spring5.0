plugins {
    id 'java'
}

group 'org.springframework'
version '5.0.16.BUILD-SNAPSHOT'

sourceCompatibility = 1.8

repositories {
    mavenCentral()
}

dependencies {
    //类似于jcl，日志门面
    /**
     * slf4j -- 绑定器 -- 具体的实现日志
     * 如果没有绑定，那么slf4j会什么都不干
     *
     * 绑定器与桥接器
     * 桥接器是指如：spring jcl-log4j  我们 app - slf4j - jul
     * 这样的话，我们需要项目就可以使用我们的app - slf4j - log4j绑定器，这样的话，就和spring同一使用log4j
     * 但是，如果我们就是想要该spring - jul打印呢？
     * 这个时候就需要使用到桥接器，当spring - jcl --- 桥接器 --- slf4j。也就是不让jcl - 走log4j
     *
     * 产生死循环，可能就是绑定器与桥接器的乱使用
     */
    //compile group: 'org.slf4j', name: 'slf4j-api', version: '1.7.25'
    // slf4j - 绑定到jul
    //compile group: 'org.slf4j', name: 'slf4j-jdk14', version: '1.7.25'
    //slf4j - 绑定到log4j  其中这个绑定器中已经包含了log4j的依赖，
    // 所以我们可以不需要添加log4j的依赖。并不是每个绑定器都会添加其相应的实现包的依赖的
    // 有的绑定器就不会添加具体实现的依赖
//    compile group: 'org.slf4j', name: 'slf4j-log4j12', version: '1.7.25'


    compile group: 'log4j', name: 'log4j', version: '1.2.17'
    //jcl
   // compile group: 'commons-logging', name: 'commons-logging', version: '1.2'

    /**
     * 桥接器，将log4j - 桥接到 slf4j中，但是项目中不能依赖log4j，
     * 因为该桥接器中已经包含了log4j，并且修改了它的源码后会做桥接，
     * 如果项目中依赖了log4j的话，就不桥接了
     */
    //compile group: 'org.slf4j', name: 'log4j-over-slf4j', version: '1.7.25'

    /**
     * spring 5的日志打印时jul
     * spring 5 这是spring5对于jcl修改了源代码，spring5默认是通过jcl 绑定 jul的方式
     * LogFactory的static中会判断是否有org.apache.logging.log4j.spi.ExtendedLogger
     * 有的话，就绑定log4j2
     * 然后再判断org.slf4j.spi.LocationAwareLogger
     * 然后再判断org.slf4j.Logger
     * 最后都没有就绑定jul
     */
    compile(project(":spring-context"))
    /**
     * spring 4的日志打印时jcl
     * spring4 是 Log
     */
    //compile group: 'org.springframework', name: 'spring-context', version: '4.3.24.RELEASE'

    testCompile group: 'junit', name: 'junit', version: '4.12'
}
